// import java.util.Random;
// import java.util.ArrayList;
// import com.datastruct.*;

// public class HeapSort {
//     public static void main(String[] args) {
//         int n = 10000;
//         Random rand = new Random();
//         Heap<Integer, Integer> heap = new Heap<>(n, false); // Max heap (true untuk min heap)

//         System.out.println("Angka acak yang dimasukkan:");
//         for (int i = 0; i < n; i++) {
//             int num = rand.nextInt(100000);
//             System.out.print(num + " ");
//             heap.add(num, num);
//         }

//         heap.buildHeap();

//         ArrayList<Integer> hasilSort = new ArrayList<>();

//         long start = System.nanoTime();
//         for (int i = 0; i < n; i++) {
//             hasilSort.add(heap.removeFirst().getKey());
//         }
//         long finish = System.nanoTime();

//         System.out.println("\n\nHasil setelah Heapsort:");
//         int count = 0;
//         for (int num : hasilSort) {
//             System.out.print(num + "\t");
//             if (++count % 10 == 0) System.out.println();
//         }

//         long timeElapsed = finish - start;
//         System.out.println("\n\nUkuran: " + n + ", Waktu: " + timeElapsed + " ns");
        
//     }
// }

// import com.datastruct.Heap;
// import java.util.Random;

// public class HeapSort {
//     public static void main(String[] args) {
//         int[] sizes = {10000, 20000, 40000, 80000};
//         Random rand = new Random();

//         for (int n : sizes) {
//             Heap<Integer, Integer> heap = new Heap<>(n, false); // true = max heap, false = min heap

//             // Bangkitkan bilangan acak dan masukkan ke heap
//             for (int i = 0; i < n; i++) {
//                 int angka = rand.nextInt(100000); // batas angka bisa diubah
//                 heap.add(angka, angka); // key dan data sama
//             }

//             System.out.println("\nUkuran data: " + n);
//             System.out.println("Beberapa data awal:");
//             for (int i = 0; i < Math.min(10, heap.size()); i++) {
//                 System.out.print(heap.getKey(i) + " ");
//             }
//             System.out.println();

//             // Waktu eksekusi HeapSort
//             long start = System.nanoTime();
//             heap.sort();
//             long finish = System.nanoTime();
//             long timeElapsed = finish - start;

//             // Tampilkan hasil sorting
//             System.out.println("Beberapa data setelah sort:");
//             for (int i = 0; i < Math.min(10, heap.size()); i++) {
//                 System.out.print(heap.getKey(i) + " ");
//             }
//             System.out.println("\nWaktu eksekusi: " + timeElapsed + " ns");

//             System.out.println("Semua data setelah sort:");
//             for (int i = 0; i < heap.size(); i++) {
//                 System.out.print(heap.getKey(i) + " ");
//             }
//             System.out.println(); // Biar rapi ganti baris
//         }
//     }
// }


import com.datastruct.Heap;
import java.util.ArrayList;
import java.util.Random;

public class HeapSort {
    public static void main(String[] args) {
        int[] sizes = {10000, 20000, 40000, 80000};

        for (int n : sizes) {
            Integer[] data = generateRandomData(n);

            // Heapsort
            Heap<Integer, Integer> heap = new Heap<>(n, false); // false = Max Heap
            for (int val : data) {
                heap.insert(val, val);
            }

            long start = System.nanoTime();
            heap.sort();
            long end = System.nanoTime();
            long heapTime = end - start;
            System.out.println("HeapSort - Ukuran: " + n + ", Waktu: " + heapTime + " ns");

            // Salin hasil heap ke array untuk sorting lainnya
            ArrayList<Integer> hasilSort = new ArrayList<>();
            while (heap.size() > 0) {
                hasilSort.add(heap.removeFirst().getKey());
            }

            Integer[] insertionInput = hasilSort.toArray(new Integer[0]);
            Integer[] selectionInput = hasilSort.toArray(new Integer[0]);
            Integer[] bubbleInput = hasilSort.toArray(new Integer[0]);

            measureSort("InsertionSort", insertionInput, HeapSort::insertionSort);
            measureSort("SelectionSort", selectionInput, HeapSort::selectionSort);
            measureSort("BubbleSort", bubbleInput, HeapSort::bubbleSort);

            System.out.println("===================================================");
        }
    }

    public static Integer[] generateRandomData(int size) {
        Integer[] arr = new Integer[size];
        Random rand = new Random();
        for (int i = 0; i < size; i++) {
            arr[i] = rand.nextInt(size * 10);
        }
        return arr;
    }

    public static void measureSort(String name, Integer[] data, RunnableSorter sorter) {
        long start = System.nanoTime();
        sorter.sort(data);
        long end = System.nanoTime();
        System.out.println(name + " - Ukuran: " + data.length + ", Waktu: " + (end - start) + " ns");
    }

    public static void insertionSort(Integer[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }

    public static void selectionSort(Integer[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int minIdx = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            int temp = arr[minIdx];
            arr[minIdx] = arr[i];
            arr[i] = temp;
        }
    }

    public static void bubbleSort(Integer[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            boolean swapped = false;
            for (int j = 0; j < arr.length - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    swapped = true;
                }
            }
            if (!swapped) break;
        }
    }

    interface RunnableSorter {
        void sort(Integer[] arr);
    }
}
